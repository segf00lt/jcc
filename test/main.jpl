/*
proc test_proc(i: int, s: []char) bool {
    x: u64 = 25;
    if s[i] {
        x += 15;
        return cast(bool)0;
    } else if s[i+1] {
        x += 15;
        x = 4;
        return cast(bool)1;
    } else {
        dummy := 1293;
    }

    while 0 {
        one :: 1;
        x -= one;
    }

    test_array := u64.[1 + 4, 2, 3];

    it := 0;
    for test_array {
        x *= test_array[it];
        it++;
    }

    y := x * 50;

    return cast(bool)2;
}

i: int = 12;
x : y;
TWO_PI := PI * 2;
PI :: TWO_PI / 2;
A :: B;
B :: C;
C :: A;
s := "hello sailor";
proc test_proc2(i: int, c: [3]*[..]char, f: float = 3.14) int, char;

*/


proc test_proc(i: int, x: int, c: char, f: float) {
    y := 15 - x << TWO;

    defer y += x / 7;

    {
        jane := 24;
        jane <<= 4;
    }

    bob := 42;

    y -= 1;
    y = 2 / y;

    i = (x + 12 * 8 + 2*x) / y;

    ptr: *s32 = cast(*void)123456;
    >ptr = 4;
    ptr[5*i] = ptr[4*x] + 65 + cast(s32)f;
    f = cast(float)y;

    a := 0;
    b := 0;

    foo: int = 3;
    addr_of_foo: *int = @foo;
    addr_addr_of_foo: **int = @addr_of_foo;
    other_addr_of_foo: *int = @>addr_of_foo;
    other_other_addr_of_foo: *int = @addr_of_foo[a + b];

    ptr_u8: *u8 = cast(*u8)cast(*void)123;
    c = >ptr_u8;
    c = >(ptr_u8 + 69);
    c = >(ptr_u8 - 42);

    ptr_f32: *f32 = cast(*f32)cast(*void)4321;
    f = >ptr_f32;
    f = >(ptr_f32 + 7);
    f = >(ptr_f32 - TWO);
    ptr_f32 += 33;
    ptr_f32 -= 4;
    ptr_f32++;
    ptr_f32--;

    i++;
    i--;

    >ptr_f32++;
    >ptr_f32--;
    //ptr_f32[i + cast(u64)ptr_u8[i * i + x] + x]--;
    ptr_f32[i + cast(u64)ptr_u8[i * i + x] + x] -= 1;

    bb: bool = i < x;

    bb = c && bb && f;
    bb = >ptr_u8 > cast(u8)i;

    if i > 0 {
        i = 9000;
    } else if i < 756 {
        test_var: u16;
        i++;
    } else if i <= x {
        x = i;
    } else {
        i = x + 65;
    }

    while x <= 0 {
        x++;
    }

    /*

    LOAD r_0, 1, 8B
    GETLOCAL r_1, addr 109, 8B
    GETLOCAL r_2, addr 0, 8B
    GETLOCAL r_3, addr 0, 8B
    GETLOCAL r_4, addr 0, 8B
    MUL r_3 8B, r_3 8B, r_4 8B
    GETLOCAL r_4, addr 8, 8B
    ADD r_3 8B, r_3 8B, r_4 8B
    GETLOCAL r_4, addr 101, 8B
    LOAD r_3, ptr_r_4, offset_r_3, 1B
    ADD r_2 8B, r_2 8B, r_3 8B
    GETLOCAL r_3, addr 8, 8B
    ADD r_2 8B, r_2 8B, r_3 8B
    LOADF r_3, ptr_r_1, offset_r_2, 4B
    FSUB r_0 4B, r_3 4B, r_0 4B
    STORF ptr_r_1, offset_r_2, r_0, 4B

    test_ptr_1: *int = cast(*void)6502;
    test_ptr_2: *int = cast(*void)5150;
    test_ptr_3: *int = cast(*void)8086;
    test_ptr_4: *int = cast(*void)2001;
    test_ptr_1[test_ptr_2[test_ptr_3[test_ptr_4[0] + i] + i] + i] = 150000000;
    */

}

TWO :: 2;
